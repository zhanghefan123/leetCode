package HASH;
//hash函数的特征
//Hash的输入域可以是无穷大，但是输出域是有穷的
//并且Hash函数如果输入确定，返回值一定是确定的
//当输入不一样的时候，也可能得到相同的输出，这就是hash冲突
//为了避免hash冲突发生太多次，我们需要让输出均匀的分布。
//这是什么意思呢，假设输入是0-98，输出可能是0 1 2，则我们需要让
//接近33 33 33个数分别对应的hash值为0 1 2
//hash函数输出中的每一位都是独立的
//虽然输入可能只有一点点不一样，经过hash函数，就可能会变得非常不一样
//所以就会将输入规律进行打乱

//假设一个hash函数的输出为16个字符，每个字符四个字节，即16进制从0-f
//我们可以将前8个字符令为h1,后八个字符令为h2，所以h1+1*h2 或者
//h1+2*h2
//应用在大数据之中，将大的任务划分为小的任务，因为不同输入均匀分布的特征


//哈希表的基本结构
/*
* 1.上来就准备一个长度为17的数组
* 2.当我们执行put操作的时候，会将key进行hashcode操作，然后再将hashcode的结果%17,
* 得到的结果将为0-16，数组之中存储的是链表的头结点，如果hashcode的结果%17的结果为n
* 就将key value放到对应的数组之中的链表的头结点之后，如果链表之中已经存在了结点
* 就向下一个点挂上。
*/

//当链表的长度过多的时候，我们就需要考虑查找效率的问题了。
// 这个时候我们需要将哈希表中的所有结点拿出来，按照新的
// hash函数重新在新的哈希表之中进行填充。hash表的增删改查是O(1)的


public class Hash {

}
