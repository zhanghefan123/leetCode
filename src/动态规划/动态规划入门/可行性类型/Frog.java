package 动态规划.动态规划入门.可行性类型;
//问题:
/*
有n块石头分别在x轴的0，1，2，…………n-1位置
一只青蛙在石头0，想要跳到石头n-1,如果青蛙在第i块石头上
则它最多可以向右跳ai,其中a是一个给定的数组，问青蛙能否跳到石头n-1

例子：
输入为a = [2,3,1,1,4] -- 解析：
第0块石头上最多可以跳2，但我只跳1步，跳到3
第1块石头上最多可以跳3，我就跳3步，跳到4，结束跳跃，成功

输入为a = [3,2,1,0,4] -- 解析：
最后只能够呆在索引为3的石头上动弹不得，所以不能到达最后一块
石头
*/
//动态规划步骤
/*
最后一步:
假设青蛙能够跳到索引为n-1的石头，我们考虑它的最后一跳
需要满足两个条件 - 1.青蛙可以跳到石头i -- 子问题
                2.最后一步不超过跳跃的最大距离 n-1-i<=ai
状态：设f[i]表示青蛙能不能跳到石头i
转移方程：f[j] = FOR(0<=i<=j)[f[i] AND (i+a[i])>=j]
    解析：f[j] -- 青蛙能否跳到石头j
        FOR(0<=i<=j) -- 枚举上一个跳到的石头i
        f[i] -- 青蛙能否跳到石头i
        i + a[i] >= j -- 从石头i上能否一步跳到石头j上
初始条件：青蛙一开始就在石头上，f[0] = True
计算顺序：f[1] f[2] …… f[n-1]
*/
public class Frog {
    public static void main(String[] args) {

    }
    public static boolean func(int[] A){
        int n = A.length;
        boolean[] f = new boolean[n];
        f[0] = true;
        for(int j = 1;j<n;j++){
            // 先假定这个位置不可能
            f[j] = false;
            // 状态转移方程的运用
            for(int i = 0; i<j; ++i){
                // 能跳到索引i这个石头，并且能从i跳到j.
                if(f[i] && i+A[i]>= j)
                {
                    // 能跳到就break就可以了。
                    f[j] = true;
                    break;
                }
            }
        }
        return f[n-1];
    }
}
