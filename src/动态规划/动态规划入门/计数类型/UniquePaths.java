package 动态规划.动态规划入门.计数类型;
//题目：
/*
给定m行，n列的网格，有一个机器人从左上角(0,0)出发，向右或者向下走
一步，问总共存在多少种不同的方式走到右下角
*/

//算法思想
/*
> 最后一步：走一步走到(m-1,n-1)

> 子问题的划分：如果机器人存在X种方式从左上角走到(m-2,n-1),有y种
方式从左上角走到(m-1,n-2),则机器人总共存在X+Y种方式走到(m-1,n-1)--利用加法原理

> 转移方程
从[0][0]到[i][j]的方式总和f[i][j]
f[i][j] = f[i-1][j] + f[i][j-1]

> 初始条件
f[0][0] = 1,机器人就在[0][0]点，只有一种
方式到[0][0]就是原地不动

> 计算顺序
先计算第0行，从左向右计算
再计算第1行，从左向右计算
……
计算第m-1行，从左向右计算
*/
public class UniquePaths {
    public static void main(String[] args) {

    }
    public static int func(int m ,int n){
        int[][] f = new int[m][n];
        //行从上到下遍历
        for(int i = 0;i<m;i++)
        {
            //列从左向右遍历
            for(int j = 0;j<m;j++)
            {
                //当是第一行或者第一列的话只有一种方式,只能一直向右或者一直向下
                if(i==0 || j==0){
                    f[i][j] = 1;
                }
                else{
                    // 上面的if条件保证了i-1和j-1必定大于等于0
                    f[i][j] = f[i-1][j] + f[i][j-1];
                }
            }
        }
        return f[m-1][n-1];
    }
}
