package 动态规划.序列型动态规划.买卖股票的最佳时机;
//题目：
/*
* 给定一只股票N天的价格，可以进行最多两次买入
* 以及两次卖出，每次买卖都是一股，不能在卖光前买入
* 但是可以同一天买完后买入
* 问最大的收益
*
* 输入举例：[4,4,6,1,1,4,2,5]
* 输出举例：6(4买入6卖出，1买入，5卖出，收益为(6-4) + (5-1) = 6)
*
* */

//问题难点
/*
> 因为最多只能够进行两次买卖
> 所以我们需要记录已经买卖了多少次。
如果之前没有买卖那么还可以买卖两次
如果之前买卖过一次那么还可以买卖一次
如果买卖过两次那么一次都不能再买。
> 所以结论是我们需要记录已经买卖了多少次。
* */

//算法分析：
/*
* 确定状态：
* 最后一步--最优策略中，最后一次卖发生在第j天。
*
* 各个阶段--参考动态规划包中老师画的阶段图
* > 阶段的变化
* > > 1.阶段可以保持，即我们不进行买卖操作
* > > 2.阶段可以通过买或者卖变化，阶段2如果我们买了一股则进入阶段3
*
* 如果要求前N天结束后--即过完了索引为N-1的一天，在阶段5的最大获利，设为f[N][5]
* f[N][5]的值存在两种情况
* --第一种情况索引为N-2天在阶段5 f[N][5] = f[N-1][5]
* --第二种情况索引为N-2天在阶段4,第N-1天卖掉 f[N-1][4] + (PN-1 - PN-2)
*
* 如果要求前N天结束后--即过完了索引为N-1的一天，在阶段4的最大获利，设为f[N][4]
* --第一种情况索引为N-2天在阶段4 f[N][4] = f[N-1][4] + (PN-1 -PN-2)
* --第二种情况索引为N-2天在阶段3
*
* 状态转移方程
* 初始状态 -- 刚开始的时候处于阶段1 -- f[0][1] = 0 f[0][2] = f[0][3] = f[0][4] = f[0][5] = -∞
* 阶段135(手中无股票状态) -- f[i][j] = max{f[i-1][j],f[i-1][j-1] + Pi-1 - Pi-2}
* 阶段24(手中有股票状态) -- f[i][j] = max{f[i-1][j]+Pi-1 - Pi-2, f[i-1][j-1]}
* 注意如果j-1<1或者i-2<0的时候，对应项不计入max
* 因为最多买卖两次，所以答案是max{f[N][1],f[N][3],f[N][5]}
* */
public class BestTimeToBuyAndSellStock3 {
    public int maxProfit(int[] prices) {
        int length = prices.length;
        if(length==0)
        {
            return 0;
        }

        // 总共存在5种状态:
        /* 1.首先是清仓状态，一次也没有买卖 -- 0状态
           2.然后是第一次持有股票状态 -- 1状态
           3.接着是清仓状态，买卖了一次 -- 2状态
           4.然后是第二次持有股票状态 -- 3状态
           5.最终是清仓状态，买卖了两次 -- 4状态
           */

        // helper[i][j] 表示在第i天处于j状态下的最大收益。

        int[][] helper = new int[length+1][5];

        // 在第0天的时候，只能处于0状态,并且没有收益
        helper[0][0] = 0;
        // 在第0天处于其他状态是不可能的，所以初始化为-∞
        for(int i = 1; i <= 4;i++)
        {
            helper[0][i] = Integer.MIN_VALUE;
        }
        // 接着遍历填充helper数组。
        // 我们要求前N天的最大收益
        /*
        1.此时即索引N-1天若处在状态4，N-2天可能是状态4,N-2天可能是状态3
        情况1：f[N][4] = f[N-1][4]
        情况2：f[N][4] = f[N-1][3] + prices[N-1] - prices[N-2]

        2.此时即索引N-1天若处在状态3,N-2天可能是状态3，N-2天可能是状态2
        // 情况1需要保证不是最后一天，以便卖出
        情况1 --继续获利: f[N][3] = f[N-1][3] + prices[N-1] - prices[N-2]
        情况2：f[N][3] = f[N-1][2]


        */
        for(int i = 1; i <= length;i++)
        {
            // 先形成 0 2 4 状态
            for(int j = 0;j<=4;j+=2)
            {
                helper[i][j] = helper[i-1][j];
                if (j >= 1 && i >= 2 && helper[i - 1][j - 1] != Integer.MIN_VALUE)
                {
                    helper[i][j] = Integer.max(helper[i][j],helper[i-1][j-1] + prices[i-1] - prices[i-2]);
                }
            }

            // 再形成 1 3 状态
            for(int j = 1;j<=3;j+=2)
            {
                helper[i][j] = helper[i-1][j-1];
                if (i >= 2 && helper[i - 1][j] != Integer.MIN_VALUE)
                {
                    helper[i][j] = Integer.max(helper[i][j],helper[i-1][j] + prices[i-1] - prices[i-2]);
                }
            }
        }
        return Math.max(helper[length][0], Math.max(helper[length][2], helper[length][4]));
    }
}