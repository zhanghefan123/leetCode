package 动态规划.划分型动态规划;
//题目:
/*
有一段由A-Z组成的字母串信息被加密称为数字串
加密的方式为A->1 …… Z->26
加密后形成一个数字串S[0……N-1]，问存在多少
种方式解密称为字母串。
*/


//算法思想
/*
* 1.最后一步 -- 肯定对应的是划分出最后一个字母
* 举例理解 --                           -方式1 将12解析成为L 假设前面的xxxx xxxx xxxx 有50种解密方式
* 数字串为 xxxx xxxx xxxx 1 2 解密方式 --
*                                     -方式2 将2解析称为B 假设前面的xxxx xxxx xxxx 1 有100种解密方式
* 所以总共存在 100 + 50 = 150种解密方式
*
* 2.子问题
* 设数字串的长度为N
* 要求数字串前N个字符的解密方式数，我们需要求字串前N-1和N-2个字符的解密方式数
*
* 3.状态
* 设数字串S前i个数字解密成字母串有f[i]种方式
*
* 4.状态转移方程
* f[i] = f[i-1]*(是否第i个数字,索引为i-1的数字能对应一个字母) + f[i-2]*(是否第i-1个和第i个数字的组合能对应一个字母)
*
* 5.初始状态
* f[0] = 0
* */
public class DecodeWays {
    public static void main(String[] args) {

    }
    public int numDecoding(String ss)
    {
        char[] s = ss.toCharArray();
        int n = s.length;
        if(n == 0)
        {
            return 0;
        }
        int [] f = new int[n+1];
        // 前0个数字的解码方式只有一种，就是空串
        f[0] = 1;
        int i,j;
        // 从前1个数字开始
        for(i = 1;i<=n;i++)
        {
            // 如果第i-1个数字在1-9之间，则加上f[i-1]
            if(s[i-1] >= '1' && s[i-1] <= '9')
            {
                f[i] += f[i-1];
            }
            // check whether i > 1 ，因为我们如果计算的是前1个数字的编码种类最大值，
            // 就不存在将最后的两位解析成一个字母的情况
            if(i>1)
            {
                // 如果第i-1和第i-2构成的数值在10-26之间则加上f[i-2]
                j = 10 * (s[i-2] - '0') + (s[i-1] - '0');
                if(j>=10 && j<=26)
                {
                    f[i] += f[i-2];
                }
            }
        }
        return f[n];
    }

}
