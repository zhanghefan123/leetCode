package 动态规划.区间和背包型动态规划.背包问题之01背包问题;
//题目
/*
* 给定N个物品，重量分别为A0 --- AN-1
* 价值分别为V0 --- VN-1
* 一个背包最大承重是正整数M
* 最多能带走多大价值的物品。
*
* */

//例子
/*
* 输入：4个物品，重量为2，3，5，7，
* 价值为1，5，2，4，背包的最大承重
* 为11，结果输出为9
* (物品1+物品3，重量=3+7=10，价值=5+4=9)
*
* */

//算法思想
/*
* 如果我们对于每个总重量，我们能够知道
* 对应的能够拼出的最大价值是多少，
* 我们就能够知道答案。
*
*
*
* 最后一步--最后一个物品(重量An-1,价值Vn-1)是否进入背包
* 选择1--不加入最后一个物品：如果前N-1个物品能拼出W，最大总价值是V，前N个
* 物品也能拼出W，并且总价值也是V。
* 选择2--加入最后一个物品：如果前N-1个物品能拼出W-An-1，最大总价值是V，那么
* 加上最后一个物品(重量An-1,价值Vn-1)，能拼出W，总价值是V+(Vn-1)
*
* 举例：假设存在3个物品，重量为2，3，5，价值为10，20，50
* 假设现在要拼出重量5，来到最后一个物品看他是否进入背包。
* 选择1--不加入：前N-1个物品能拼出W=5，最大总价值为10+20 = 30
* 选择2--加入：前N-1个物品能拼出W-5=0，最大总价值为0+50 = 50
* 所以选取最大的的即为50。
*
* 子问题：
* 要求前N个物品能不能拼出重量0，1……M,以及拼出重量W所能获得的最大价值
* 需要知道前N-1个物品能不能拼出0，1……M，以及拼出重量W所能获得的最大价值
*
* 状态：
* 设f[i][w] = 用前i个物品拼出w质量的时候的最大总价值(值为-1表示不能够拼出质量w)
*
* 状态转移方程：
* f[i][w] = max{f[i-1][w],(f[i-1][w-Ai-1]+ Vi-1)且 (w>=Ai-1) 且 f[i-1][w-A(i-1)]!=-1}
*
* 初始条件：
* f[0][0] = 0 -- 0个物品可以拼出重量0，最大总价值是0
* f[0][1……M] = -1 -- 0个物品不能拼出大于0的重量
*
* 返回值：
* max(0<=j<=M){f[N][j] | f[N][j]!=-1}
* */
public class BackPack2 {
    public int backPackII(int m,int[] A,int[] V)
    {
        int n = A.length;
        if(n == 0)
        {
            return 0;
        }
        int[][] f= new int[n+1][m+1];
        int i,w;
        f[0][0] = 0;
        for(i = 1;i <= m;i++)
        {
            f[0][i] = -1;
        }

        for(i=1;i<=n;i++)
        {
            for(w=0;w<=m;w++)
            {
                //第一种情况--最后一个元素不进行加入
                f[i][w] = f[i-1][w];
                //第二种情况--在满足情况的条件下，加入最后一个元素
                if(w>=A[i-1] && f[i-1][w-A[i-1]]!=-1)
                {
                    f[i][w] = Math.max(f[i][w],f[i-1][w-A[i-1]]+V[i-1]);
                }
            }
        }
        int res = 0;
        for(w=0;w<=m;w++)
        {
            if (f[n][w]!=-1) {
                res = Math.max(res,f[n][w]);
            }
        }
        return res;
    }
}
