package 动态规划.区间和背包型动态规划.背包型动态规划;
//题目
/*
* 背包问题概述：
* 你有一个背包，背包中有最大承重
* 商店之中有若干物品都是免费拿取，每个物品有重量和价值
*
* 背包问题目标：
* --装下最多重量的物品
* --装下最大总价值的物品
* --有多少种方式正好带走满满一书包的物品
*
* 背包问题数组大小与背包容量M有关。
* */

//可行性背包

//最简单的背包问题
//给定N个物品，重量分别为正整数A0，A1，A2……AN-1
//一个背包最大的承重是正整数M，最多能带走多重的物品。


//算法思想
/*
* 给定N个物品，重量分别为正整数A0，A1,……AN-1
* 一个背包的最大承重为M，物品的重量都是整数，每个装物品的方案的总
* 重量都是0-M的闭区间之中的一个数，如果对于每个总重量我们能知道
* 有没有方案能够做到，就可以解决。我们仅仅需要选取的是最接近背包容量
* 并且能够做到的方案
*
*
* 动态规划组成部分1：状态的确定
* 最后一步--最后一个物品(重量An-1)是否进入背包
* 情况1 -- 如果前N-1个物品能拼出W，当然前N个物品也能够拼出W
* 情况2 -- 如果前N-1个物品能拼出W-(An-1),再加上最后的物品An-1拼出W
*
* 状态f[i][w]表示的含义是是否能够使用前i个物品拼出重量w(True/False)
* 要求使用前N个物品能否拼出0-M，需要知道前N-1个物品能否拼出0-M
*
* 状态转移方程f[i][w] = f[i-1][w] OR f[i-1][w-(Ai-1)]
* 分析 -- 能否用前i个物品拼出重量w = 能否用前i-1个物品拼出重量w或者能否用前i-1个物品拼出（总重量-第i-1个物品的重量）。
*
* 初始条件
* f[0][0] = True 0个物品可以拼出重量0
* f[0][1……M] = False 0个物品不能拼出大于0的重量。
*
* 最后的结果为最靠近后面的结果为
* * */
public class BackPack {
    public static void main(String[] args) {

    }
    public int backPack(int m,int[] A)
    {
        int n = A.length;
        if(n == 0)
        {
            return 0;
        }
        // 最后一步：
        /*
        第一步--[第一个物品是否进入背包]
        第二步--[第二个物品是否进入背包]
        ……
        最后一步--[最后一个物品是否进入背包]
        */

        // 原问题：
        /*
        前N个物品能否拼凑出重量M
        */

        // 子问题：
        /*
        *
        索引N-1物品的重量为A(N-1)
        前N-1个物品能否拼凑出重量M,前N-1个物品能否拼凑出重量M-A(N-1)
        满足上述一个条件即可。
        */

        // 状态f[i][j]
        // 能否用前i个物品拼凑出重量j
        boolean[][] f = new boolean[n+1][m+1];
        int i,j;
        // 前0个物体可以拼凑出重量0
        f[0][0] = true;
        // 前0个物体不可以拼凑出大于0的重量。
        for(i = 1;i<=m;i++)
        {
            f[0][i] = false;
        }
        // 我们遍历前i个物品。
        for(i=1;i<=n;i++)
        {
            // 我们遍历前j个重量。
            for(j=0;j<=m;j++)
            {
                // 使用前i-1个物品就能够拼出j
                f[i][j] = f[i-1][j];
                if(j>=A[i-1])
                {
                    // 使用前i-1个物品拼凑出j-A[i-1]
                    f[i][j] |= f[i-1][j-A[i-1]];
                }
            }
        }

        int res = 0;
        // 找出前n个物体所能够拼出的最大重量。
        for(i=m;i>=0;i--)
        {
            if(f[n][i] = true)
            {
                res = i;
                break;
            }
        }
        return res;
    }
}
