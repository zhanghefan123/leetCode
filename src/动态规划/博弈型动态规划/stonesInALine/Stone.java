package 动态规划.博弈型动态规划.stonesInALine;

//题目：
//存在一排N个石子，Alice Bob这两个人轮流取石子
//每次一个人可以从最右边取走1个或者2个石子
//取走最后石子的人获胜，问先手的Alice是否必胜或者必败

//算法分析:
//我们看石子问题这个图
/*
* 假设我们一开始存在5个石子，Alice先手。
* Alice此时应该选择一种必败的局面，而这种局面会落在Bob的手上。
* Alice这时选择拿走两个石子，此时还剩下3个元素。
* 这种局面是一个必败的局面，他无法留给Alice一个必败的局面
* 因为无论Bob拿1个石子，还是拿两个石子，剩下的2个石子或者1个石子的局面
* 对于Alice都是必胜的局面
*
*
* 第一步开始分析：
* 由于博弈越到后面情况越少，所以我们需要从第一步开始进行分析
*
* 子问题：
* 面对N个石子，是否先手必胜
* 需要知道面对N-1个石子和N-2个石子是否先手必胜，
* 状态F[i]表示面对i个石子，是否先手必胜。
*
* 状态转移方程：
* 1.当面对N个石子的时候，
* 如果是必胜的话，
* 那么必然存在F[i-1]为必败，或者F[i-2]为必败，或者F[i-1]和F[i-2]都是必败
* 如果是必败的话，
* 那么F[i-1]和F[i-2]都需要是必胜的局面。
*
* 2.总结状态转移方程
* f[i] = f[i-1] == False OR f[i-2] == false
*
* 3.计算顺序，f[0]……f[N]
*
* 4.初始条件，f[0] = false f[1] = true f[2] = true
* */
public class Stone {
    public boolean firstWillWin(int n) {
        // 如果0个石子，返回false
        if (n == 0)
        {
            return false;
        }
        // 如果剩一个石子，返回true
        if(n==1)
        {
            return true;
        }
        boolean[] f = new boolean[n+1];
        int i;
        f[0] = false;
        f[1] = true;
        for(i = 2; i<=n;i++)
        {
            // 在面对i个石子能够必胜的前提是，在面对i-1和i-2石头必输
            f[i] = (!f[i-1]) || (!f[i-2]);
        }
        return f[n];
    }
}
