1.递归的三大要素
> -- 第一要素：明确这个函数想要干什么
对于递归，我觉得很重要的一个事情就是，这个函数的功能是什么，他要完成什么样的一件事情，而这个，是完全由
你自己来进行定义的，也就是说，我们先不用管函数之中具体的代码是什么，而是先要弄明白，我们这个函数是要来
干什么
比如代码：
// 算 n 的阶乘(假设n不为0)
int f(int n){

}

> -- 第二要素：寻找递归的结束条件
所谓递归，就是会在函数内部代码中，调用这个函数本身，所以我们必须要找出递归的结束条件，不然的话，会一直调用
自身，进入无限循环最终栈溢出，也就是说我们需要找出当参数为什么情况的时候丢i结束，之后直接将结果进行返回，请
注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。
比如代码：
// 算 n 的阶乘(假设n不为0)
int f(int n){
    if(n == 1){
        return 1;
    }
}
//有人可能会说，当n=2的时候我们可以直接知道f(n)等于多少，那我们可以将n=2作为递归的结束条件吗?答案是当然可以的，
// 算 n 的阶乘(假设n>=2)
int f(int n){
    if(n == 2){
        return 2;
    }
}

> -- 找出函数的等价关系式
第三要素就是我们需要不断的缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使
原函数的结果不变，例如f(n)这个范围比较大，我们可以让f(n) = n * f(n-1).这样范围就由n
变成了n-1，范围变小了，并且为了原函数f(n)不变，我们需要让f(n-1) * n,说白了就是要找到
原函数的一个等价关系式。

如下所示
// 算 n 的阶乘(假设n不为0)
int f(int n){
    if(n <= 2){
        return n;
    }
    // 把 f(n) 的等价操作写进去
    return f(n-1) * n;
}

//按照上述思路进行解决--题目1

题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
1、第一递归函数功能
假设 f(n) 的功能是求青蛙跳上一个n级的台阶总共有多少种跳法，代码如下：
int f(int n){

}

2.找出递归结束的条件
我说了，求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少，所以当 n = 1时，你知道 f(1) 为多少吧？够直观吧？即 f(1) = 1。代码如下
int f(int n){
    if(n == 1){
        return 1;
    }
}

第三要素：找出函数的等价关系式
每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。
第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。
第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。
所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：
int f(int n){
    if(n == 1){
        return 1;
    }
    return f(n-1) + f(n-2);
}
大家觉得上面的代码对不对？

答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入死循环。

这也是我要和你们说的，关于递归结束条件是否够严谨问题，有很多人在使用递归的时候，由于结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。就像上面，f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。代码如下：

int f(int n){
    //f(0) = 0,f(1) = 1，等价于 n<=1时，f(n) = n。
    if(n <= 1){
        return n;
    }
    return f(n-1) + f(n-2);
}

//反转单链表
反转单链表。例如链表为：1->2->3->4。反转后为 4->3->2->1
//链表结点定义如下
class Node{
    int date;
    Node next;
}
//1.定义递归函数功能
假设函数 reverseList(head) 的功能是反转但链表，其中 head 表示链表的头节点。代码如下：

Node reverseList(Node head){

}


//2.寻找结束条件
Node reverseList(Node head){
    if(head == null || head.next == null){
        return head;
    }
}

//3.寻找等价关系
//假如 1 -> 2 -> 3 -> 4 那么如果我们先将后面的2 3 4进行倒置。
//变成了 4 -> 3 -> 2 <- 1 我们还需要做什么呢，便是只需要将 1->2进行反转即可
//用递归的方法反转链表
public static Node reverseList2(Node head){
    // 1.递归结束条件
    if (head == null || head.next == null) {
             return head;
         }
         // 递归反转 子链表
         Node newList = reverseList2(head.next);
         // 改变 1，2节点的指向。
         // 通过 head.next获取节点2
         Node t1  = head.next;
         // 让 2 的 next 指向 1
         t1.next = head;
         // 1 的 next 指向 null.
        head.next = null;
        // 把调整之后的链表返回。
        return newList;
    }


